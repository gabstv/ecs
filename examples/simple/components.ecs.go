// Code generated by ecs https://github.com/gabstv/ecs; DO NOT EDIT.
package simple

import (
	"github.com/gabstv/ecs/v2"
	"sort"
)

const (
	uuidPositionComponent = "3DF7F486-807D-4CE8-A187-37CED338137B"
	capPositionComponent  = 256
)

type drawerPositionComponent struct {
	Entity ecs.Entity
	Data   Position
}

// PositionComponentObserver is a helper struct to access a valid pointer of Position
type PositionComponentObserver interface {
	Entity() ecs.Entity
	Data() *Position
}
type slcdrawerPositionComponent []drawerPositionComponent

// Len implementation of sort.Interface.Len
func (a slcdrawerPositionComponent) Len() int {
	return len(a)
}

// Swap implementation of sort.Interface.Swap
func (a slcdrawerPositionComponent) Swap(i int, j int) {
	a[i], a[j] = a[j], a[i]
}

// Less implementation of sort.Interface.Less
func (a slcdrawerPositionComponent) Less(i int, j int) bool {
	return a[i].Entity < a[j].Entity
}

type mPositionComponentObserver struct {
	c      *PositionComponent
	entity ecs.Entity
}

func (w *mPositionComponentObserver) Entity() ecs.Entity {
	return w.entity
}
func (w *mPositionComponentObserver) Data() *Position {

	id := w.c.indexof(w.entity)
	if id == -1 {
		return nil
	}
	return &w.c.data[id].Data
}

// PositionComponent handles the component logic of the Position. Implements ecs.Component
type PositionComponent struct {
	initialized bool
	flag        ecs.Flag
	world       ecs.World
	wkey        [4]byte
	data        []drawerPositionComponent
}

// GetPositionComponent returns the instance of the component in a World
func GetPositionComponent(w ecs.World) *PositionComponent {
	return w.C(uuidPositionComponent).(*PositionComponent)
}

// GetPositionComponentData returns the data of the component in a World
func GetPositionComponentData(w ecs.World, e ecs.Entity) *Position {
	return GetPositionComponent(w).Data(e)
}

// SetPositionComponentData updates/adds a Position to Entity e
func SetPositionComponentData(w ecs.World, e ecs.Entity, data Position) {
	GetPositionComponent(w).Upsert(e, data)
}

// WatchPositionComponentData gets a pointer getter of an entity's Position.
// The pointer must not be stored because it may become invalid over time.
func WatchPositionComponentData(w ecs.World, e ecs.Entity) PositionComponentObserver {
	return &mPositionComponentObserver{
		c:      GetPositionComponent(w),
		entity: e,
	}
}

// UUID implements ecs.Component
func (PositionComponent) UUID() string {
	return uuidPositionComponent
}

// Name implements ecs.Component
func (PositionComponent) Name() string {
	return "PositionComponent"
}

// World implements ecs.Component
func (c *PositionComponent) World() ecs.World {
	return c.world
}
func (c *PositionComponent) indexof(e ecs.Entity) int {
	i := sort.Search(len(c.data), func(i int) bool {
		return c.data[i].Entity >= e
	})
	if i < len(c.data) && c.data[i].Entity == e {
		return i
	}
	return -1
}

// Upsert creates or updates a component data of an entity.
// Not recommended to be used directly. Use SetPositionComponentData to change component
// data outside of a system loop.
func (c *PositionComponent) Upsert(e ecs.Entity, data interface{}) (added bool) {
	added = false
	v, ok := data.(Position)
	if !ok {
		panic("data must be Position")
	}

	id := c.indexof(e)

	if id > -1 {

		dwr := &c.data[id]
		dwr.Data = v

	} else {
		added = true
	}

	rsz := false
	if cap(c.data) == len(c.data) {
		rsz = true
		c.world.CWillResize(c, c.wkey)

	}
	newindex := len(c.data)
	c.data = append(c.data, drawerPositionComponent{
		Entity: e,
		Data:   v,
	})
	if len(c.data) > 1 {
		if c.data[newindex].Entity < c.data[newindex-1].Entity {
			c.world.CWillResize(c, c.wkey)

			sort.Sort(slcdrawerPositionComponent(c.data))
			rsz = true
		}
	}

	if rsz {

		c.world.CResized(c, c.wkey)
		ecs.DispatchComponentEvent(c, ecs.EvtComponentsResized, 0)
	}

	c.world.CAdded(e, c, c.wkey)
	ecs.DispatchComponentEvent(c, ecs.EvtComponentAdded, e)
	return
}

// Remove a Position data from entity e
// Returns false if the component was not present in Entity e
func (c *PositionComponent) Remove(e ecs.Entity) bool {

	i := c.indexof(e)
	if i == -1 {
		return false
	}

	c.data = c.data[:i+copy(c.data[i:], c.data[i+1:])]
	c.world.CRemoved(e, c, c.wkey)

	ecs.DispatchComponentEvent(c, ecs.EvtComponentRemoved, e)
	return true
}

// Data retrieves the *Position of entity e. Warning: volatile pointer (do not store)
func (c *PositionComponent) Data(e ecs.Entity) *Position {

	index := c.indexof(e)
	if index > -1 {
		return &c.data[index].Data
	}
	return nil
}

// Flag returns the flag of this component
func (c *PositionComponent) Flag() ecs.Flag {
	return c.flag
}

// GetPositionComponentFlag returns the flag of this component
func GetPositionComponentFlag(w ecs.World) ecs.Flag {
	return GetPositionComponent(w).Flag()
}

// Setup is called by ecs.World
// Do not call this by yourself
func (c *PositionComponent) Setup(w ecs.World, f ecs.Flag, key [4]byte) {
	if c.initialized {
		panic("PositionComponent called Setup() more than once")
	}
	c.flag = f
	c.world = w
	c.wkey = key
	c.data = make([]drawerPositionComponent, 0, capPositionComponent)
	c.initialized = true

}
func init() {
	ecs.RegisterComponent(func() ecs.Component {
		return &PositionComponent{}
	})
}

const (
	uuidRotationComponent = "55AFAC07-F446-4DBE-B963-413B0C38E72B"
	capRotationComponent  = 256
)

type drawerRotationComponent struct {
	Entity ecs.Entity
	Data   Rotation
}

// RotationComponentObserver is a helper struct to access a valid pointer of Rotation
type RotationComponentObserver interface {
	Entity() ecs.Entity
	Data() *Rotation
}
type slcdrawerRotationComponent []drawerRotationComponent

// Len implementation of sort.Interface.Len
func (a slcdrawerRotationComponent) Len() int {
	return len(a)
}

// Swap implementation of sort.Interface.Swap
func (a slcdrawerRotationComponent) Swap(i int, j int) {
	a[i], a[j] = a[j], a[i]
}

// Less implementation of sort.Interface.Less
func (a slcdrawerRotationComponent) Less(i int, j int) bool {
	return a[i].Entity < a[j].Entity
}

type mRotationComponentObserver struct {
	c      *RotationComponent
	entity ecs.Entity
}

func (w *mRotationComponentObserver) Entity() ecs.Entity {
	return w.entity
}
func (w *mRotationComponentObserver) Data() *Rotation {

	id := w.c.indexof(w.entity)
	if id == -1 {
		return nil
	}
	return &w.c.data[id].Data
}

// RotationComponent handles the component logic of the Rotation. Implements ecs.Component
type RotationComponent struct {
	initialized bool
	flag        ecs.Flag
	world       ecs.World
	wkey        [4]byte
	data        []drawerRotationComponent
}

// GetRotationComponent returns the instance of the component in a World
func GetRotationComponent(w ecs.World) *RotationComponent {
	return w.C(uuidRotationComponent).(*RotationComponent)
}

// GetRotationComponentData returns the data of the component in a World
func GetRotationComponentData(w ecs.World, e ecs.Entity) *Rotation {
	return GetRotationComponent(w).Data(e)
}

// SetRotationComponentData updates/adds a Rotation to Entity e
func SetRotationComponentData(w ecs.World, e ecs.Entity, data Rotation) {
	GetRotationComponent(w).Upsert(e, data)
}

// WatchRotationComponentData gets a pointer getter of an entity's Rotation.
// The pointer must not be stored because it may become invalid over time.
func WatchRotationComponentData(w ecs.World, e ecs.Entity) RotationComponentObserver {
	return &mRotationComponentObserver{
		c:      GetRotationComponent(w),
		entity: e,
	}
}

// UUID implements ecs.Component
func (RotationComponent) UUID() string {
	return uuidRotationComponent
}

// Name implements ecs.Component
func (RotationComponent) Name() string {
	return "RotationComponent"
}

// World implements ecs.Component
func (c *RotationComponent) World() ecs.World {
	return c.world
}
func (c *RotationComponent) indexof(e ecs.Entity) int {
	i := sort.Search(len(c.data), func(i int) bool {
		return c.data[i].Entity >= e
	})
	if i < len(c.data) && c.data[i].Entity == e {
		return i
	}
	return -1
}

// Upsert creates or updates a component data of an entity.
// Not recommended to be used directly. Use SetRotationComponentData to change component
// data outside of a system loop.
func (c *RotationComponent) Upsert(e ecs.Entity, data interface{}) (added bool) {
	added = false
	v, ok := data.(Rotation)
	if !ok {
		panic("data must be Rotation")
	}

	id := c.indexof(e)

	if id > -1 {

		dwr := &c.data[id]
		dwr.Data = v

	} else {
		added = true
	}

	rsz := false
	if cap(c.data) == len(c.data) {
		rsz = true
		c.world.CWillResize(c, c.wkey)

	}
	newindex := len(c.data)
	c.data = append(c.data, drawerRotationComponent{
		Entity: e,
		Data:   v,
	})
	if len(c.data) > 1 {
		if c.data[newindex].Entity < c.data[newindex-1].Entity {
			c.world.CWillResize(c, c.wkey)

			sort.Sort(slcdrawerRotationComponent(c.data))
			rsz = true
		}
	}

	if rsz {

		c.world.CResized(c, c.wkey)
		ecs.DispatchComponentEvent(c, ecs.EvtComponentsResized, 0)
	}

	c.world.CAdded(e, c, c.wkey)
	ecs.DispatchComponentEvent(c, ecs.EvtComponentAdded, e)
	return
}

// Remove a Rotation data from entity e
// Returns false if the component was not present in Entity e
func (c *RotationComponent) Remove(e ecs.Entity) bool {

	i := c.indexof(e)
	if i == -1 {
		return false
	}

	c.data = c.data[:i+copy(c.data[i:], c.data[i+1:])]
	c.world.CRemoved(e, c, c.wkey)

	ecs.DispatchComponentEvent(c, ecs.EvtComponentRemoved, e)
	return true
}

// Data retrieves the *Rotation of entity e. Warning: volatile pointer (do not store)
func (c *RotationComponent) Data(e ecs.Entity) *Rotation {

	index := c.indexof(e)
	if index > -1 {
		return &c.data[index].Data
	}
	return nil
}

// Flag returns the flag of this component
func (c *RotationComponent) Flag() ecs.Flag {
	return c.flag
}

// GetRotationComponentFlag returns the flag of this component
func GetRotationComponentFlag(w ecs.World) ecs.Flag {
	return GetRotationComponent(w).Flag()
}

// Setup is called by ecs.World
// Do not call this by yourself
func (c *RotationComponent) Setup(w ecs.World, f ecs.Flag, key [4]byte) {
	if c.initialized {
		panic("RotationComponent called Setup() more than once")
	}
	c.flag = f
	c.world = w
	c.wkey = key
	c.data = make([]drawerRotationComponent, 0, capRotationComponent)
	c.initialized = true

}
func init() {
	ecs.RegisterComponent(func() ecs.Component {
		return &RotationComponent{}
	})
}

const (
	uuidVelocityComponent = "d1ceb219-c860-49ac-9a4d-2ab99e1477c8"
	capVelocityComponent  = 256
)

type drawerVelocityComponent struct {
	Entity ecs.Entity
	Data   Velocity
}

// VelocityComponentObserver is a helper struct to access a valid pointer of Velocity
type VelocityComponentObserver interface {
	Entity() ecs.Entity
	Data() *Velocity
}
type slcdrawerVelocityComponent []drawerVelocityComponent

// Len implementation of sort.Interface.Len
func (a slcdrawerVelocityComponent) Len() int {
	return len(a)
}

// Swap implementation of sort.Interface.Swap
func (a slcdrawerVelocityComponent) Swap(i int, j int) {
	a[i], a[j] = a[j], a[i]
}

// Less implementation of sort.Interface.Less
func (a slcdrawerVelocityComponent) Less(i int, j int) bool {
	return a[i].Entity < a[j].Entity
}

type mVelocityComponentObserver struct {
	c      *VelocityComponent
	entity ecs.Entity
}

func (w *mVelocityComponentObserver) Entity() ecs.Entity {
	return w.entity
}
func (w *mVelocityComponentObserver) Data() *Velocity {

	id := w.c.indexof(w.entity)
	if id == -1 {
		return nil
	}
	return &w.c.data[id].Data
}

// VelocityComponent handles the component logic of the Velocity. Implements ecs.Component
type VelocityComponent struct {
	initialized bool
	flag        ecs.Flag
	world       ecs.World
	wkey        [4]byte
	data        []drawerVelocityComponent
}

// GetVelocityComponent returns the instance of the component in a World
func GetVelocityComponent(w ecs.World) *VelocityComponent {
	return w.C(uuidVelocityComponent).(*VelocityComponent)
}

// GetVelocityComponentData returns the data of the component in a World
func GetVelocityComponentData(w ecs.World, e ecs.Entity) *Velocity {
	return GetVelocityComponent(w).Data(e)
}

// SetVelocityComponentData updates/adds a Velocity to Entity e
func SetVelocityComponentData(w ecs.World, e ecs.Entity, data Velocity) {
	GetVelocityComponent(w).Upsert(e, data)
}

// WatchVelocityComponentData gets a pointer getter of an entity's Velocity.
// The pointer must not be stored because it may become invalid over time.
func WatchVelocityComponentData(w ecs.World, e ecs.Entity) VelocityComponentObserver {
	return &mVelocityComponentObserver{
		c:      GetVelocityComponent(w),
		entity: e,
	}
}

// UUID implements ecs.Component
func (VelocityComponent) UUID() string {
	return uuidVelocityComponent
}

// Name implements ecs.Component
func (VelocityComponent) Name() string {
	return "VelocityComponent"
}

// World implements ecs.Component
func (c *VelocityComponent) World() ecs.World {
	return c.world
}
func (c *VelocityComponent) indexof(e ecs.Entity) int {
	i := sort.Search(len(c.data), func(i int) bool {
		return c.data[i].Entity >= e
	})
	if i < len(c.data) && c.data[i].Entity == e {
		return i
	}
	return -1
}

// Upsert creates or updates a component data of an entity.
// Not recommended to be used directly. Use SetVelocityComponentData to change component
// data outside of a system loop.
func (c *VelocityComponent) Upsert(e ecs.Entity, data interface{}) (added bool) {
	added = false
	v, ok := data.(Velocity)
	if !ok {
		panic("data must be Velocity")
	}

	id := c.indexof(e)

	if id > -1 {

		dwr := &c.data[id]
		dwr.Data = v

	} else {
		added = true
	}

	rsz := false
	if cap(c.data) == len(c.data) {
		rsz = true
		c.world.CWillResize(c, c.wkey)

	}
	newindex := len(c.data)
	c.data = append(c.data, drawerVelocityComponent{
		Entity: e,
		Data:   v,
	})
	if len(c.data) > 1 {
		if c.data[newindex].Entity < c.data[newindex-1].Entity {
			c.world.CWillResize(c, c.wkey)

			sort.Sort(slcdrawerVelocityComponent(c.data))
			rsz = true
		}
	}

	if rsz {

		c.world.CResized(c, c.wkey)
		ecs.DispatchComponentEvent(c, ecs.EvtComponentsResized, 0)
	}

	c.world.CAdded(e, c, c.wkey)
	ecs.DispatchComponentEvent(c, ecs.EvtComponentAdded, e)
	return
}

// Remove a Velocity data from entity e
// Returns false if the component was not present in Entity e
func (c *VelocityComponent) Remove(e ecs.Entity) bool {

	i := c.indexof(e)
	if i == -1 {
		return false
	}

	c.data = c.data[:i+copy(c.data[i:], c.data[i+1:])]
	c.world.CRemoved(e, c, c.wkey)

	ecs.DispatchComponentEvent(c, ecs.EvtComponentRemoved, e)
	return true
}

// Data retrieves the *Velocity of entity e. Warning: volatile pointer (do not store)
func (c *VelocityComponent) Data(e ecs.Entity) *Velocity {

	index := c.indexof(e)
	if index > -1 {
		return &c.data[index].Data
	}
	return nil
}

// Flag returns the flag of this component
func (c *VelocityComponent) Flag() ecs.Flag {
	return c.flag
}

// GetVelocityComponentFlag returns the flag of this component
func GetVelocityComponentFlag(w ecs.World) ecs.Flag {
	return GetVelocityComponent(w).Flag()
}

// Setup is called by ecs.World
// Do not call this by yourself
func (c *VelocityComponent) Setup(w ecs.World, f ecs.Flag, key [4]byte) {
	if c.initialized {
		panic("VelocityComponent called Setup() more than once")
	}
	c.flag = f
	c.world = w
	c.wkey = key
	c.data = make([]drawerVelocityComponent, 0, capVelocityComponent)
	c.initialized = true

}
func init() {
	ecs.RegisterComponent(func() ecs.Component {
		return &VelocityComponent{}
	})
}

const (
	uuidMovementSystem = "E7D2FB64-2E98-4A14-8DE6-F088DE2AC3FB"
	nameMovementSystem = "MovementSystem"
)

type viewMovementSystem struct {
	entities []VIMovementSystem
	world    ecs.World
}
type VIMovementSystem struct {
	Entity   ecs.Entity
	Position *Position
	Rotation *Rotation
	Velocity *Velocity
}
type sortedVIMovementSystems []VIMovementSystem

// Len implementation of sort.Interface.Len
func (a sortedVIMovementSystems) Len() int {
	return len(a)
}

// Swap implementation of sort.Interface.Swap
func (a sortedVIMovementSystems) Swap(i int, j int) {
	a[i], a[j] = a[j], a[i]
}

// Less implementation of sort.Interface.Less
func (a sortedVIMovementSystems) Less(i int, j int) bool {
	return a[i].Entity < a[j].Entity
}
func newviewMovementSystem(w ecs.World) *viewMovementSystem {
	return &viewMovementSystem{
		entities: make([]VIMovementSystem, 0),
		world:    w,
	}
}
func (v *viewMovementSystem) Matches() []VIMovementSystem {
	return v.entities
}
func (v *viewMovementSystem) indexof(e ecs.Entity) int {
	i := sort.Search(len(v.entities), func(i int) bool {
		return v.entities[i].Entity >= e
	})
	if i < len(v.entities) && v.entities[i].Entity == e {
		return i
	}
	return -1
}

// Fetch a specific entity
func (v *viewMovementSystem) Fetch(e ecs.Entity) (data VIMovementSystem, ok bool) {

	i := v.indexof(e)
	if i == -1 {
		return VIMovementSystem{}, false
	}
	return v.entities[i], true
}

// Add a new entity
func (v *viewMovementSystem) Add(e ecs.Entity) bool {

	// MUST NOT add an Entity twice:
	if i := v.indexof(e); i > -1 {
		return false
	}
	v.entities = append(v.entities, VIMovementSystem{
		Entity:   e,
		Position: GetPositionComponentData(v.world, e),
		Rotation: GetRotationComponentData(v.world, e),
		Velocity: GetVelocityComponentData(v.world, e),
	})
	if len(v.entities) > 1 {
		if v.entities[len(v.entities)-1].Entity < v.entities[len(v.entities)-2].Entity {
			sort.Sort(sortedVIMovementSystems(v.entities))
		}
	}
	return true
}

// Remove an entity
func (v *viewMovementSystem) Remove(e ecs.Entity) bool {

	if i := v.indexof(e); i != -1 {
		v.entities = append(v.entities[:i], v.entities[i+1:]...)
		return true
	}
	return false
}
func (v *viewMovementSystem) clearpointers() {

	for i := range v.entities {
		e := v.entities[i].Entity
		v.entities[i].Position = nil
		v.entities[i].Rotation = nil
		v.entities[i].Velocity = nil
		_ = e
	}
}
func (v *viewMovementSystem) rescan() {

	for i := range v.entities {
		e := v.entities[i].Entity
		v.entities[i].Position = GetPositionComponentData(v.world, e)
		v.entities[i].Rotation = GetRotationComponentData(v.world, e)
		v.entities[i].Velocity = GetVelocityComponentData(v.world, e)
		_ = e
	}
}

// MovementSystem implements ecs.System
type MovementSystem struct {
	ecs.BaseSystem
	initialized bool
	world       ecs.World
	view        *viewMovementSystem
	lastdt      float64
}

// GetMovementSystem returns the instance of the system in a World
func GetMovementSystem(w ecs.World) *MovementSystem {
	return w.S(uuidMovementSystem).(*MovementSystem)
}

// UUID implements ecs.System
func (MovementSystem) UUID() string {
	return uuidMovementSystem
}

// Name implements ecs.System
func (MovementSystem) Name() string {
	return nameMovementSystem
}
func addRemoveMatchFnMovementSystem(f ecs.Flag, w ecs.World) bool {
	if !f.Contains(GetPositionComponentFlag(w)) {
		return false
	}
	if !f.Contains(GetRotationComponentFlag(w)) {
		return false
	}
	if !f.Contains(GetVelocityComponentFlag(w)) {
		return false
	}
	return true
}
func resizeMatchFnMovementSystem(f ecs.Flag, w ecs.World) bool {
	return addRemoveMatchFnMovementSystem(f, w)
}

// ensure matchfn
var _ ecs.MatchFn = addRemoveMatchFnMovementSystem

// ensure resizematchfn
var _ ecs.MatchFn = resizeMatchFnMovementSystem

func (s *MovementSystem) match(eflag ecs.Flag) bool {
	return addRemoveMatchFnMovementSystem(eflag, s.world)
}
func (s *MovementSystem) resizematch(eflag ecs.Flag) bool {
	return resizeMatchFnMovementSystem(eflag, s.world)
}
func (s *MovementSystem) ComponentAdded(e ecs.Entity, eflag ecs.Flag) {
	if s.match(eflag) {
		if s.view.Add(e) {
			s.onEntityAdded(e)
		}
	} else {
		if s.view.Remove(e) {
			s.onEntityRemoved(e)
		}
	}
}
func (s *MovementSystem) ComponentRemoved(e ecs.Entity, eflag ecs.Flag) {
	if s.match(eflag) {
		if s.view.Add(e) {
			s.onEntityAdded(e)
		}
	} else {
		if s.view.Remove(e) {
			s.onEntityRemoved(e)
		}
	}
}
func (s *MovementSystem) ComponentResized(cflag ecs.Flag) {
	if s.resizematch(cflag) {
		s.view.rescan()
		s.onComponentResized(cflag)
	}
}
func (s *MovementSystem) ComponentWillResize(cflag ecs.Flag) {
	if s.resizematch(cflag) {
		s.onComponentWillResize(cflag)
		s.view.clearpointers()
	}
}
func (s *MovementSystem) V() *viewMovementSystem {
	return s.view
}
func (s *MovementSystem) View() *viewMovementSystem {
	return s.view
}
func (s *MovementSystem) Priority() int64 {
	return int64(0)
}
func (s *MovementSystem) Setup(w ecs.World) {
	if s.initialized {
		panic("MovementSystem called Setup() more than once")
	}
	s.view = newviewMovementSystem(w)
	s.world = w
	s.BaseSystem.Enable()
	s.initialized = true
	s.onSetup(w)
}
func init() {
	ecs.RegisterSystem(func() ecs.System {
		return &MovementSystem{}
	})
}
