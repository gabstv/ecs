// Code generated by ecs https://github.com/gabstv/ecs; DO NOT EDIT.

package {{.Package}}

import (
    {{if .Async}}"sync"{{end}}
    "sort"

    "github.com/gabstv/ecs"
)

{{$type := (printf "%sSystem" .Name)}}
{{$uuid := (or .Vars.UUID $type)}}
{{$matchfn := (or .Vars.Match (printf "match%s" $type))}}
{{$view := (printf "view%s" $type)}}
{{$viewitem := (printf "VI%s" $type)}}
{{$priority := (or .Vars.Priority "0")}}

const uuid{{$type}} = "{{$uuid}}"

type {{$view}} struct {
    entities []{{$viewitem}}
    world ecs.BaseWorld
    {{if .Async}}l        sync.RWMutex{{end}}
}

type {{$viewitem}} struct {
    Entity ecs.Entity
    {{range $v := .ViewItems}}
    {{$v.Name}} {{$v.Type}} 
    {{end}}
}

type sorted{{$viewitem}}s []{{$viewitem}}
func (a sorted{{$viewitem}}s) Len() int           { return len(a) }
func (a sorted{{$viewitem}}s) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a sorted{{$viewitem}}s) Less(i, j int) bool { return a[i].Entity < a[j].Entity }

func new{{$view}}(w ecs.BaseWorld) *{{$view}} {
    return &{{$view}}{
        entities: make([]{{$viewitem}}, 0),
        world: w,
    }
}

func (v *{{$view}}) Matches() []{{$viewitem}} {
    {{if .Async}}
    v.l.RLock()
    defer v.l.RUnlock()
    eclone := make([]ecs.Entity, len(v.entities))
    copy(eclone, v.entities)
    return eclone
    {{else}}
    return v.entities
    {{end}}
}

func (v *{{$view}}) indexof(e ecs.Entity) int {
    i := sort.Search(len(v.entities), func(i int) bool { return v.entities[i].Entity >= e })
    if i < len(v.entities) && v.entities[i].Entity == e {
        return i
    }
    return -1
}

func (v *{{$view}}) Add(e ecs.Entity) bool {
    {{if .Async}}v.l.Lock(){{end}}
    {{if .Async}}defer v.l.Unlock(){{end}}
    // MUST NOT add an Entity twice:
    if i := v.indexof(e); i > -1 {
        return false
    }
    v.entities = append(v.entities, {{$viewitem}}{
        Entity: e,
        {{range $v := .ViewItems}}{{$v.Name}}: {{$v.Getter}},
{{end}}
    })
    if len(v.entities) > 1 {
        if v.entities[len(v.entities)-1].Entity < v.entities[len(v.entities)-2].Entity {
            sort.Sort(sorted{{$viewitem}}s(v.entities))
        }
    }
    return true
}

func (v *{{$view}}) Remove(e ecs.Entity) bool {
    {{if .Async}}v.l.Lock(){{end}}
    {{if .Async}}defer v.l.Unlock(){{end}}
    if i := v.indexof(e); i != -1 {

        v.entities = append(v.entities[:i], v.entities[i+1:]...)
        return true
    }
    return false
}

// {{$type}} implements ecs.BaseSystem
type {{$type}} struct {
    initialized bool
    world       ecs.BaseWorld
    view        *{{$view}}
    enabled     bool
}

// Get{{$type}} returns the instance of the system in a World
func Get{{$type}}(w ecs.BaseWorld) *{{$type}} {
    return w.S(uuid{{$type}}).(*{{$type}})
}

// Enable system
func (s *{{$type}}) Enable() {
    s.enabled = true
}

// Disable system
func (s *{{$type}}) Disable() {
    s.enabled = false
}

// Enabled checks if enabled
func (s *{{$type}}) Enabled() bool {
    return s.enabled
}

// UUID implements ecs.BaseSystem
func ({{$type}}) UUID() string {
    return "{{$uuid}}"
}

func ({{$type}}) Name() string {
    return "{{$type}}"
}

// ensure matchfn
var _ ecs.MatchFn = {{$matchfn}}

func (c *{{$type}}) match(eflag ecs.Flag) bool {
    return {{$matchfn}}(eflag, c.world)
}

func (c *{{$type}}) ComponentAdded(e ecs.Entity, eflag ecs.Flag) {
    if c.match(eflag) {
        if c.view.Add(e) {
            // TODO: dispatch event that this entity was added to this system
        }
    } else {
        if c.view.Remove(e) {
            // TODO: dispatch event that this entity was removed from this system
        }
    }
}

func (c *{{$type}}) ComponentRemoved(e ecs.Entity, eflag ecs.Flag) {
    if c.match(eflag) {
        if c.view.Add(e) {
            // TODO: dispatch event that this entity was added to this system
        }
    } else {
        if c.view.Remove(e) {
            // TODO: dispatch event that this entity was removed from this system
        }
    }
}

func (c *{{$type}}) V() *{{$view}} {
    return c.view
}

func (c *{{$type}}) Priority() int64 {
    return {{$priority}}
}

func (c *{{$type}}) Setup(w ecs.BaseWorld) {
    if c.initialized {
        panic("{{$type}} called Setup() more than once")
    }
    c.view = new{{$view}}(w)
    c.world = w
    c.enabled = true
    c.initialized = true
}

{{if not .SkipRegister}}
func init() {
    ecs.RegisterSystem(func() ecs.BaseSystem {
        return &{{$type}}{}
    })
}
{{end}}